import{createPage as D,preparePageComponent as O,preparePageData as B,preparePagesComponents as S,preparePagesData as V,preparePagesRoutes as j}from"@vuepress/core";import{getDirname as K,path as A}from"@vuepress/utils";import{watch as G}from"chokidar";import{Logger as J,addViteSsrNoExternal as z}from"vuepress-shared";import{removeLeadingSlash as I}from"@vuepress/shared";const n=new J("vuepress-plugin-blog2"),U=(t,b)=>{const u={};return Object.keys({"/":{},...b.options.locales}).forEach(l=>{u[l]=[]}),b.pages.filter(t).forEach(l=>{u[l.pathLocale].push(l)}),u},F=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updateBlogCategory) {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap)
  })
}
`,H=(t,b,u,l=!1)=>{const{category:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=b;return Promise.all(M.map(async({key:e,getter:o,sorter:a=()=>-1,path:p="/:key/",layout:c="Layout",frontmatter:d=()=>({}),itemPath:g="/:key/:name/",itemLayout:_="Layout",itemFrontmatter:y=()=>({})},r)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${r}]'`),null;if(typeof o!="function")return n.error(`Invalid 'getter' option in 'category[${r}]', it should be a function!`),null;t.env.isDebug&&n.info(`Generating ${e} category.
`);const k={},$=[],v=typeof g=="function"?g:i=>(g||"").replace(/:key/g,m(e)).replace(/:name/g,m(i));for(const i in u){if(p){const f=`${i}${I(p.replace(/:key/g,m(e)))}`,h=await D(t,{path:f,frontmatter:{...d(i),blog:{type:"category",key:e},layout:c}}),s=t.pages.findIndex(({path:E})=>E===f);s===-1?t.pages.push(h):t.pages[s].key!==h.key&&(t.pages.splice(s,1,h),l&&n.warn(`Overiding existed path ${f}`)),$.push(h.key),k[i]={path:h.path,map:{}}}else k[i]={path:"",map:{}};const{map:w}=k[i],P={};for(const f of u[i]){const h=o(f);for(const s of h){if(!w[s]){const E=v(s);if(E){const T=`${i}${I(E)}`,R=await D(t,{path:`${i}${I(E)}`,frontmatter:{...y(s,i),blog:{type:"category",name:s,key:e},layout:_}}),x=t.pages.findIndex(({path:N})=>N===T);x===-1?t.pages.push(R):t.pages[x].key!==R.key&&(t.pages.splice(x,1,R),l&&n.warn(`Overiding existed path ${T}`)),$.push(R.key),w[s]={path:R.path,keys:[]}}else w[s]={path:"",keys:[]};P[s]=[]}P[s].push(f)}}for(const f in P)w[f].keys=P[f].sort(a).map(({key:h})=>h);if(t.env.isDebug){let f=`Route ${i} in ${e} cateogry:
`;for(const h in w){const{path:s,keys:E}=w[h];f+=`name: ${h}; ${s?`path: ${s}; `:""}items: ${E.length}
`}n.info(f)}}return{key:e,map:k,pageKeys:$}})).then(async e=>{const o={},a=[];return e.filter(p=>p!==null).forEach(({key:p,map:c,pageKeys:d})=>{o[p]=c,a.push(...d)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(o)}
${F}`),t.env.isDebug&&n.info("All categories generated."),a})},W=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updateBlogType) {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap)
  })
}
`,C=(t,b,u,l=!1)=>{const{type:M=[],slugify:m=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=b;return Promise.all(M.map(async({key:e,sorter:o=()=>-1,filter:a=()=>!0,path:p="/:key/",layout:c="Layout",frontmatter:d=()=>({})},g)=>{if(typeof e!="string"||!e)return n.error(`Invalid 'key' option ${e} in 'category[${g}]'`),null;const _={},y=[];t.env.isDebug&&n.info(`Generating ${e} type.
`);for(const r in u){const k=u[r].filter(a).sort(o).map(({key:$})=>$);if(p){const $=`${r}${I(m(p.replace(/:key/g,e)))}`,v=await D(t,{path:$,frontmatter:{...d(r),blog:{type:"type",key:e},layout:c}}),i=t.pages.findIndex(({path:w})=>w===$);i===-1?t.pages.push(v):t.pages[i].key!==v.key&&(t.pages.splice(i,1,v),l&&n.warn(`Overiding existed path ${$}`)),y.push(v.key),_[r]={path:v.path,keys:k},t.env.isDebug&&n.info(`Route ${r} in ${e} type: path: ${v.path}; items: ${k.length}
`)}else _[r]={path:"",keys:k},t.env.isDebug&&n.info(`Route ${r} in ${e} type: items: ${k.length}
`)}return{key:e,map:_,pageKeys:y}})).then(async e=>{const o={},a=[];return e.filter(p=>p!==null).forEach(({key:p,map:c,pageKeys:d})=>{o[p]=c,a.push(...d)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(o)}
${W}`),t.env.isDebug&&n.info("All types generated."),a})},q=K(import.meta.url),L=t=>b=>{const{getInfo:u=()=>({}),filter:l=e=>Boolean(e.filePathRelative)&&!e.frontmatter.home,metaScope:M="_blog"}=t;let m=[];return b.env.isDebug&&n.info(`Options: ${t.toString()}`),{name:"vuepress-plugin-blog2",define:()=>({BLOG_META_SCOPE:M}),alias:{"vuepress-plugin-blog2/client":A.resolve(q,"../client/index.js")},extendsBundlerOptions:(e,o)=>{z({app:o,config:e},"vuepress-shared")},extendsPage:e=>{l(e)&&(e.routeMeta={...M===""?u(e):{[M]:u(e)},...e.routeMeta})},onInitialized:e=>{const o=U(l,e);return Promise.all([H(e,t,o,!0).then(a=>{m.push(...a)}),C(e,t,o,!0).then(a=>{m.push(...a)})]).then(()=>{e.env.isDebug&&n.info("temp file generated")})},onWatched:(e,o)=>{if(t.hotReload){const a=G("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),p=()=>{const c=[],d=U(l,e);return Promise.all([H(e,t,d).then(g=>{c.push(...g)}),C(e,t,d).then(g=>{c.push(...g)})]).then(async()=>{const g=m.filter(y=>!c.includes(y)),_=c.filter(y=>!m.includes(y));_.length&&(e.env.isDebug&&n.info(`New pages detected: ${_.toString()}`),await Promise.all(_.map(async y=>{await O(e,e.pages.find(({key:r})=>r===y)),await B(e,e.pages.find(({key:r})=>r===y))}))),g.length&&(e.env.isDebug&&n.info(`Removing following pages: ${g.toString()}`),g.forEach(y=>{e.pages.splice(e.pages.findIndex(({key:r})=>r===y),1)})),(g.length||_.length)&&(await S(e),await V(e),await j(e)),m=c,e.env.isDebug&&n.info("temp file updated")})};a.on("add",()=>{p()}),a.on("change",()=>{p()}),a.on("unlink",()=>{p()}),o.push(a)}}}};export{L as blogPlugin,L as default};
//# sourceMappingURL=index.js.map
